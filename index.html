<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>技术博客</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="React, Webpack, Javascript 等技术文章">
<meta property="og:type" content="website">
<meta property="og:title" content="技术博客">
<meta property="og:url" content="https://dedoyle.github.io/kuibu/index.html">
<meta property="og:site_name" content="技术博客">
<meta property="og:description" content="React, Webpack, Javascript 等技术文章">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="dong">
<meta property="article:tag" content="React, Webpack, Javascript, 前端">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/kuibu/atom.xml" title="技术博客" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/kuibu/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/kuibu/css/style.css">

  
    
<link rel="stylesheet" href="/kuibu/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 5.4.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/kuibu/" id="logo">技术博客</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/kuibu/">Home</a>
        
          <a class="main-nav-link" href="/kuibu/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/kuibu/atom.xml" title="RSS 订阅"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="搜索"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://dedoyle.github.io/kuibu"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-Event-Loop" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/kuibu/2022/01/09/Event-Loop/" class="article-date">
  <time class="dt-published" datetime="2022-01-09T13:39:00.000Z" itemprop="datePublished">2022-01-09</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/kuibu/2022/01/09/Event-Loop/">Event Loop</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>whatwg 的标准里面讲了，为了协调事件、用户交互、脚本、渲染、网络等，用户代理必须使用事件循环。每个代理都有一个关联的事件循环，这是该代理独有的。</p>
<blockquote>
<p>The event loop of a similar-origin window agent is known as a window event loop. The event loop of a dedicated worker agent, shared worker agent, or service worker agent is known as a worker event loop. And the event loop of a worklet agent is known as a worklet event loop.</p>
</blockquote>
<p>一个事件循环有一个或多个 task queues。一个 task queue 是一个 tasks set。</p>
<blockquote>
<p>Task queues are sets, not queues, because step one of the event loop processing model grabs the first runnable task from the chosen queue, instead of dequeuing the first task.<br>The microtask queue is not a task queue.</p>
</blockquote>
<h2 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h2><p>任务封装了如下的算法：</p>
<ul>
<li>Event: 派发一个事件给特定的 target 经常是由专门的任务去完成的。</li>
<li>Parsing： HTML 解析通常是一个任务。</li>
<li>Callbacks：调用一个回调经常是由一个专门的任务完成。</li>
<li>Using a resource</li>
<li>Reacting to DOM manipulation: 一些元素具有响应 DOM 操作而触发的任务，例如当该元素插入到 document 中时。</li>
</ul>
<p>任务是一个结构, 它具有：</p>
<ul>
<li><p>steps<br>A series of steps specifying the work to be done by the task.</p>
</li>
<li><p>source<br>One of the task sources, used to group and serialize related tasks.</p>
</li>
<li><p>document<br>A Document associated with the task, or null for tasks that are not in a window event loop.</p>
</li>
<li><p>A script evaluation environment settings object set<br>A set of environment settings objects used for tracking script evaluation during the task.</p>
<p>每个任务都来自特定的任务源。本质上，在标准中任务源用于划分逻辑上不同类型的任务，用户代理使用任务队列来合并事件循环中的任务源。</p>
</li>
</ul>
<p>例子：</p>
<p>一个用户代理可以有一个鼠标和按键事件的任务队列（用户交互任务源与之相关联），而另一个任务队列则与所有其他任务源相关联。 然后，使用在事件循环处理模型的初始步骤中授予的自由度，它可以在四分之三的时间内让键盘和鼠标事件优先于其他任务，保持界面响应但不会饿死其他任务队列。请注意，在此设置中，处理模型仍然强制用户代理永远不会无序地处理来自任何一个任务源的事件。</p>
<p>每个事件循环都有一个当前正在运行的任务，可以是一个任务或 null。默认为 null。<br>每个事件循环都有一个微任务队列，是一个微任务的队列，初始为空。</p>
<h3 id="通用任务源"><a href="#通用任务源" class="headerlink" title="通用任务源"></a>通用任务源</h3><ul>
<li><p>DOM 操作任务源<br>此任务源用于对 DOM 操作做出反应的功能，例如在将元素插入文档时以非阻塞方式发生的事情。</p>
</li>
<li><p>用户交互任务源<br>此任务源用于响应用户交互的功能，例如键盘或鼠标输入。<br>为响应用户输入而发送的 <code>click</code> 事件（例如事件）必须使用与用户交互任务源一起排队的任务来触发。[UI 事件]</p>
</li>
<li><p>网络任务源<br>此任务源用于响应网络活动而触发的功能。</p>
</li>
<li><p>历史遍历任务源<br>此任务源用于对调用 <code>history.back()</code> 和类似 API 进行排队。</p>
</li>
</ul>
<h2 id="事件循环的处理模式"><a href="#事件循环的处理模式" class="headerlink" title="事件循环的处理模式"></a>事件循环的处理模式</h2><p>根据 whatwg 关于事件循环标准中 <a target="_blank" rel="noopener" href="https://html.spec.whatwg.org/multipage/webappapis.html#event-loop-processing-model">Processing model</a>，当一个事件循环存在，它就会不断的执行一下步骤:</p>
<ul>
<li>让任务队列成为事件循环的任务队列，选择的任务队列必须包含至少一个可执行的任务，若没有这样的队列，则直接跳到 Mircotasks 步骤。</li>
<li>从任务队列里取出第一个可执行的任务</li>
<li>将该任务赋给事件循环的 <code>currently running task</code></li>
<li>记录任务起始时间</li>
<li>执行任务</li>
<li>事件循环</li>
<li>将事件循环的 <code>currently running task</code> 重置为 null</li>
<li>Mircotasks: 执行 <code>microtask checkpoint</code><ul>
<li>如果 <code>microtask checkpoint</code> 是 true 则返回</li>
<li>将 <code>microtask checkpoint</code> 设置为 true</li>
<li>当微任务队列不为空：<ul>
<li>从微任务队列出列一个微任务</li>
<li>执行该微任务</li>
</ul>
</li>
<li>将 <code>microtask checkpoint</code> 设置为 false</li>
</ul>
</li>
<li>将 <code>hasARenderingOpportunity</code> 置为 false</li>
<li>记录当前时间</li>
<li>report 任务执行时间</li>
<li>更新渲染：如果这个事件循环是 <code>window event loop</code>：<ul>
<li>令 docs 为该事件循环的所有 Document 对象</li>
<li>渲染机会：从 docs 中删除浏览上下文没有渲染机会的所有 Document 对象<br>如果用户代理当前能够向用户呈现浏览上下文的内容，浏览上下文就有渲染机会。<br>浏览上下文呈现机会是根据硬件约束（例如显示刷新率）和其他因素（例如页面性能或文档的可见性状态是否为 <code>visible</code>）确定的。<br>渲染机会通常定期发生。<br>标准不强制要求按任何特定模型来选择渲染机会。比如，如果浏览器试图达到 60Hz 刷新率，那么渲染机会最多可达每秒 60 次，每次大约 16.7ms。<br>如果浏览器发现浏览上下文无法维持此速率，则该浏览上下文可能会下降到更可持续的每秒 30 次渲染机会，而不是偶尔丢帧。如果浏览上下文不可见，user agent 可能会决定将该页面降低到每秒 4 次甚至更低的频率。</li>
<li>如果 docs 不为空，将 <code>hasARenderingOpportunity</code> 为 true。</li>
<li>不必要的渲染：满足以下两个条件的 Document 将被从 docs 中移除：<ul>
<li>user agent 认为更新 Document 浏览上下文的渲染不会有明显的效果，并且</li>
<li>Document 的 <code>map of animation frame callback</code> 为空（可以理解为 <code>requestAnimationFrame callback</code> 为空）。</li>
</ul>
</li>
<li>对于 docs 对象中的每个活动 document 文档<ul>
<li><a target="_blank" rel="noopener" href="https://html.spec.whatwg.org/multipage/interaction.html#flush-autofocus-candidates">刷新 autofocus</a>。</li>
<li><a target="_blank" rel="noopener" href="https://drafts.csswg.org/cssom-view/#run-the-resize-steps">执行 resize 步骤</a>。</li>
<li><a target="_blank" rel="noopener" href="https://drafts.csswg.org/cssom-view/#run-the-scroll-steps">执行 scroll 步骤</a>。</li>
<li><a target="_blank" rel="noopener" href="https://drafts.csswg.org/cssom-view/#evaluate-media-queries-and-report-changes">执行媒体查询</a>。</li>
<li><a target="_blank" rel="noopener" href="https://drafts.csswg.org/web-animations/#update-animations-and-send-events">更新动画并发送事件</a>。</li>
<li><a target="_blank" rel="noopener" href="https://fullscreen.spec.whatwg.org/#run-the-fullscreen-steps">执行全屏步骤</a>。</li>
<li>user agent 检测到与 <code>CanvasRenderingContext2D</code> 或 <code>OffscreenCanvasRenderingContext2D</code> 关联的 context 已经丢失，则执行 <code>context to lost</code> 步骤。</li>
<li><a target="_blank" rel="noopener" href="https://html.spec.whatwg.org/multipage/imagebitmap-and-animations.html#run-the-animation-frame-callbacks">执行 animationFrame 回调</a>，即 requestAnimationFrame 的回调。</li>
<li><a target="_blank" rel="noopener" href="https://w3c.github.io/IntersectionObserver/#run-the-update-intersection-observations-steps">执行 intersection observations 步骤</a>，即 <code>IntersectionObserver</code> 回调。</li>
<li>调用 <code>mark paint timeing</code> 算法。</li>
<li>更新 Document 对应的呈现或用户界面及其浏览上下文，以反映当前状态。</li>
</ul>
</li>
</ul>
</li>
<li>如果以下所有都为真<ul>
<li>this is a window event loop</li>
<li>in this event loop’s task queues, there is no task whose document is fully active</li>
<li>this event loop’s microtask queue is empty</li>
<li>hasARenderingOpportunity is false<br>则：<ul>
<li>计算 <code>computeDeadline</code></li>
<li>为带 <code>computeDeadline</code> 的 window 执行 <a target="_blank" rel="noopener" href="https://w3c.github.io/requestidlecallback/#start-an-idle-period-algorithm">start an idle period algorithm</a>（requestIdleCallback）</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="微任务排队"><a href="#微任务排队" class="headerlink" title="微任务排队"></a>微任务排队</h2><p>根据 <a target="_blank" rel="noopener" href="https://html.spec.whatwg.org/multipage/timers-and-user-prompts.html#microtask-queuing">whatwg 标准 微任务排队</a>，<code>self.queueMicrotask(callback)</code> 可用于在微任务队列上添加微任务。这允许他们的代码在下一次 js 执行上下文堆栈为空时运行。 不过，调度大量微任务和运行大量同步代码具有相同的性能劣势。两者都会阻止浏览器渲染。</p>
<p>在很多情况下，<code>requestAnimationFrame()</code> 或者 <code>requestIdleCallback()</code> 是更好的选择。特别是，如果目标是在下一个渲染周期之前运行代码，就用 <code>requestAnimationFrame()</code>。</p>
<p><code>queueMicrotask()</code> 最常见的使用场景是创建一致的排序，即使在信息同步可用的情况下，也不会引入过度延迟。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">MyElement.prototype.loadData = <span class="function"><span class="keyword">function</span> (<span class="params">url</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">this</span>._cache[url]) &#123;</span><br><span class="line">    queueMicrotask(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>._setData(<span class="built_in">this</span>._cache[url])</span><br><span class="line">      <span class="built_in">this</span>.dispatchEvent(<span class="keyword">new</span> Event(<span class="string">&#x27;load&#x27;</span>))</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    fetch(url)</span><br><span class="line">      .then(<span class="function">(<span class="params">res</span>) =&gt;</span> res.arrayBuffer())</span><br><span class="line">      .then(<span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>._cache[url] = data</span><br><span class="line">        <span class="built_in">this</span>._setData(data)</span><br><span class="line">        <span class="built_in">this</span>.dispatchEvent(<span class="keyword">new</span> Event(<span class="string">&#x27;load&#x27;</span>))</span><br><span class="line">      &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样能保证有无 cache 运行顺序都一致。</p>
<p>另一个使用场景是实现不协调的“批处理”，比如说，你想尽可能快地将数据发送出去，但又不想发出多个网络请求，这时就可以用 <code>queueMicrotask</code>：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> queuedToSend = []</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sendData</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">  queuedToSend.push(data)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (queuedToSend.length === <span class="number">1</span>) &#123;</span><br><span class="line">    queueMicrotask(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> stringToSend = <span class="built_in">JSON</span>.stringify(queuedToSend)</span><br><span class="line">      queuedToSend.length = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">      fetch(<span class="string">&#x27;/endpoint&#x27;</span>, stringToSend)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>浏览器中的事件循环主要由 Task、Microtask 和 Render 三个过程组成，每一轮事件循环都会检查两个任务队列是否有要执行的任务，等 js 上下文执行栈清空后，先清空微任务队列里所有的任务，然后判断是否需要渲染，如果不需要渲染继续下一轮循环。所以一般情况下，不是每一轮事件循环都会渲染，如果想在每次事件循环中或微任务之后执行一次绘制，可以通过 <code>requestAnimationFrame</code> 重新渲染。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://dedoyle.github.io/kuibu/2022/01/09/Event-Loop/" data-id="ckyfvgn5y00000fib9nd55r8s" data-title="Event Loop" class="article-share-link">分享</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-React-是什么" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/kuibu/2021/12/23/React-%E6%98%AF%E4%BB%80%E4%B9%88/" class="article-date">
  <time class="dt-published" datetime="2021-12-23T14:35:09.000Z" itemprop="datePublished">2021-12-23</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/kuibu/2021/12/23/React-%E6%98%AF%E4%BB%80%E4%B9%88/">React 状态更新</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="React-的架构大概分为"><a href="#React-的架构大概分为" class="headerlink" title="React 的架构大概分为"></a>React 的架构大概分为</h2><ul>
<li>Scheduler（调度器）—— 调度任务的优先级，高优任务优先进入 Reconciler</li>
<li>Reconciler（协调器）—— 负责找出变化的组件</li>
<li>Renderer（渲染器）—— 负责将变化的组件渲染到页面上</li>
</ul>
<p>Reconciler 工作的阶段被称为 render 阶段。因为在该阶段会调用组件的 render 方法。<br>Renderer 工作的阶段被称为 commit 阶段。就像你完成一个需求的编码后执行 git commit 提交代码。commit 阶段会把 render 阶段提交的信息渲染在页面上。<br>render 与 commit 阶段统称为 work，即 React 在工作中。相对应的，如果任务正在 Scheduler 内调度，就不属于 work。</p>
<h2 id="Render-阶段"><a href="#Render-阶段" class="headerlink" title="Render 阶段"></a>Render 阶段</h2><p>Render 阶段开始于 performSyncWorkOnRoot 或 performConcurrentWorkOnRoot 方法的调用。这取决于本次更新是同步更新还是异步更新。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// performSyncWorkOnRoot会调用该方法</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">workLoopSync</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (workInProgress !== <span class="literal">null</span>) &#123;</span><br><span class="line">    performUnitOfWork(workInProgress)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// performConcurrentWorkOnRoot会调用该方法</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">workLoopConcurrent</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (workInProgress !== <span class="literal">null</span> &amp;&amp; !shouldYield()) &#123;</span><br><span class="line">    performUnitOfWork(workInProgress)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，他们唯一的区别是是否调用 shouldYield。如果当前浏览器帧没有剩余时间，shouldYield 会中止循环，直到浏览器有空闲时间后再继续遍历。</p>
<p>workInProgress 代表当前已创建的 workInProgress fiber。</p>
<p>performUnitOfWork 方法会创建下一个 Fiber 节点并赋值给 workInProgress，并将 workInProgress 与已创建的 Fiber 节点连接起来构成 Fiber 树。</p>
<p>我们知道 Fiber Reconciler 是从 Stack Reconciler 重构而来，通过遍历的方式实现可中断的递归，所以 performUnitOfWork 的工作可以分为两部分：“递”和“归”</p>
<h3 id="“递”阶段"><a href="#“递”阶段" class="headerlink" title="“递”阶段"></a>“递”阶段</h3><p>首先从 rootFiber 开始向下深度优先遍历。为遍历到的每个 Fiber 节点调用 beginWork 方法。<br>该方法会根据传入的 Fiber 节点创建子 Fiber 节点，并将这两个 Fiber 节点连接起来。<br>当遍历到叶子节点（即没有子组件的组件）时就会进入“归”阶段。</p>
<h3 id="“归”阶段"><a href="#“归”阶段" class="headerlink" title="“归”阶段"></a>“归”阶段</h3><p>在“归”阶段会调用 completeWork 处理 Fiber 节点。<br>当某个 Fiber 节点执行完 completeWork，<br>如果其存在兄弟 Fiber 节点（即 fiber.sibling !== null），会进入其兄弟 Fiber 的“递”阶段。<br>如果不存在兄弟 Fiber，会进入父级 Fiber 的“归”阶段。</p>
<p>“递”和“归”阶段会交错执行直到“归”到 rootFiber。至此，render 阶段的工作就结束了。</p>
<p>render 阶段全部工作完成。在 performSyncWorkOnRoot 函数中 fiberRootNode 被传递给 commitRoot 方法，开启 commit 阶段工作流程。</p>
<h2 id="commit-阶段"><a href="#commit-阶段" class="headerlink" title="commit 阶段"></a>commit 阶段</h2><p>commitRoot 方法是 commit 阶段工作的起点。fiberRootNode 会作为传参。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">commitRoot(root)</span><br></pre></td></tr></table></figure>

<p>在 rootFiber.firstEffect 上保存了一条需要执行副作用的 Fiber 节点的单向链表 effectList，这些 Fiber 节点的 updateQueue 中保存了变化的 props。</p>
<p>这些副作用对应的 DOM 操作在 commit 阶段执行。</p>
<p>除此之外，一些生命周期钩子（比如 componentDidXXX）、hook（比如 useEffect）需要在 commit 阶段执行。</p>
<p>commit 阶段的主要工作（即 Renderer 的工作流程）分为三部分：</p>
<ul>
<li>before mutation 阶段（执行 DOM 操作前）</li>
<li>mutation 阶段（执行 DOM 操作）</li>
<li>layout 阶段（执行 DOM 操作后）</li>
</ul>
<p>在 before mutation 阶段之前和 layout 阶段之后还有一些额外工作，涉及到比如 useEffect 的触发、优先级相关的重置、ref 的绑定/解绑。</p>
<h3 id="before-mutation-之前"><a href="#before-mutation-之前" class="headerlink" title="before mutation 之前"></a>before mutation 之前</h3><p>commitRootImpl 方法中直到第一句 <code>if (firstEffect !== null)</code> 之前属于 before mutation 之前。</p>
<p>before mutation 之前主要做一些变量赋值，状态重置的工作。</p>
<h3 id="layout-之后"><a href="#layout-之后" class="headerlink" title="layout 之后"></a>layout 之后</h3><p>主要包括三点内容：</p>
<ul>
<li>useEffect 相关的处理。</li>
<li>性能追踪相关。<br>源码里有很多和 interaction 相关的变量。他们都和追踪 React 渲染时间、性能相关，在 Profiler API 和 DevTools 中使用。</li>
<li>在 commit 阶段会触发一些生命周期钩子（如 componentDidXXX）和 hook（如 useLayoutEffect、useEffect）。</li>
</ul>
<p>在这些回调方法中可能触发新的更新，新的更新会开启新的 render-commit 流程。</p>
<h3 id="before-mutation"><a href="#before-mutation" class="headerlink" title="before mutation"></a>before mutation</h3><p>before mutation 阶段的代码很短，整个过程就是遍历 effectList 并调用 commitBeforeMutationEffects 函数处理。</p>
<h4 id="commitBeforeMutationEffects"><a href="#commitBeforeMutationEffects" class="headerlink" title="commitBeforeMutationEffects"></a>commitBeforeMutationEffects</h4><p>整体可以分为三部分：</p>
<ol>
<li>处理 DOM 节点渲染/删除后的 autoFocus、blur 逻辑。</li>
<li>调用 getSnapshotBeforeUpdate 生命周期钩子。</li>
<li>调度 useEffect。</li>
</ol>
<h5 id="调用-getSnapshotBeforeUpdate"><a href="#调用-getSnapshotBeforeUpdate" class="headerlink" title="调用 getSnapshotBeforeUpdate"></a>调用 getSnapshotBeforeUpdate</h5><p>从 Reactv16 开始，componentWillXXX 钩子前增加了 UNSAFE_ 前缀。</p>
<p>究其原因，是因为 Stack Reconciler 重构为 Fiber Reconciler 后，render 阶段的任务可能中断/重新开始，对应的组件在 render 阶段的生命周期钩子（即 componentWillXXX ）可能触发多次。</p>
<p>为此，React 提供了替代的生命周期钩子 getSnapshotBeforeUpdate，可用于替换现有的 componentWillUnMount。</p>
<p>我们可以看见，getSnapshotBeforeUpdate 是在 commit 阶段内的 before mutation 阶段调用的，由于 commit 阶段是同步的，所以不会遇到多次调用的问题。</p>
<h5 id="调度-useEffect"><a href="#调度-useEffect" class="headerlink" title="调度 useEffect"></a>调度 useEffect</h5><p>scheduler 的 scheduleCallback，用于以某个优先级异步调度一个回调函数。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 调度useEffect</span></span><br><span class="line"><span class="keyword">if</span> ((effectTag &amp; Passive) !== NoEffect) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!rootDoesHavePassiveEffects) &#123;</span><br><span class="line">    rootDoesHavePassiveEffects = <span class="literal">true</span></span><br><span class="line">    scheduleCallback(NormalSchedulerPriority, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 触发useEffect</span></span><br><span class="line">      flushPassiveEffects()</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>被异步调度的回调函数就是触发 useEffect 的方法 flushPassiveEffects。下面看看为 useEffect 如何以及为何被异步调度。</p>
<h5 id="如何异步调度-useEffect"><a href="#如何异步调度-useEffect" class="headerlink" title="如何异步调度 useEffect"></a>如何异步调度 useEffect</h5><p>flushPassiveEffects 方法内部会从全局变量 rootWithPendingPassiveEffects 获取 effectList。</p>
<p>effectList 中保存了需要执行副作用的 Fiber 节点。其中副作用包括</p>
<ul>
<li>插入 DOM 节点（Placement）</li>
<li>更新 DOM 节点（Update）</li>
<li>删除 DOM 节点（Deletion）</li>
</ul>
<p>关于 flushPassiveEffects 的具体讲解参照 useEffect 与 useLayoutEffect 一节</p>
<p>effectList 中保存了需要执行副作用的 Fiber 节点。其中副作用包括</p>
<ul>
<li>插入 DOM 节点（Placement）</li>
<li>更新 DOM 节点（Update）</li>
<li>删除 DOM 节点（Deletion）</li>
</ul>
<p>当一个 FunctionComponent 含有 useEffect 或 useLayoutEffect，他对应的 Fiber 节点也会被赋值 effectTag。</p>
<p>整个 useEffect 异步调用分为三步：</p>
<ul>
<li>before mutation 阶段在 scheduleCallback 中调度 flushPassiveEffects</li>
<li>layout 阶段之后将 effectList 赋值给 rootWithPendingPassiveEffects</li>
<li>scheduleCallback 触发 flushPassiveEffects，flushPassiveEffects 内部遍历 rootWithPendingPassiveEffects</li>
</ul>
<p>为什么需要异步调用<br>摘录自 React 文档 effect 的执行时机：</p>
<p>与 componentDidMount、componentDidUpdate 不同的是，在浏览器完成布局与绘制之后，传给 useEffect 的函数会延迟调用。这使得它适用于许多常见的副作用场景，比如设置订阅和事件处理等情况，因此不应在函数中执行阻塞浏览器更新屏幕的操作。</p>
<p>可见，useEffect 异步执行的原因主要是<strong>防止同步执行时阻塞浏览器渲染</strong>。</p>
<h3 id="mutation-阶段"><a href="#mutation-阶段" class="headerlink" title="mutation 阶段"></a>mutation 阶段</h3><p>mutation 阶段也是遍历 effectList，执行函数。这里执行的是 commitMutationEffects。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">nextEffect = firstEffect</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    commitMutationEffects(root, renderPriorityLevel)</span><br><span class="line">  &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">    invariant(nextEffect !== <span class="literal">null</span>, <span class="string">&#x27;Should be working on an effect.&#x27;</span>)</span><br><span class="line">    captureCommitPhaseError(nextEffect, error)</span><br><span class="line">    nextEffect = nextEffect.nextEffect</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="keyword">while</span> (nextEffect !== <span class="literal">null</span>)</span><br></pre></td></tr></table></figure>

<h4 id="commitMutationEffects"><a href="#commitMutationEffects" class="headerlink" title="commitMutationEffects"></a>commitMutationEffects</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">commitMutationEffects</span>(<span class="params">root: FiberRoot, renderPriorityLevel</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 遍历effectList</span></span><br><span class="line">  <span class="keyword">while</span> (nextEffect !== <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> effectTag = nextEffect.effectTag</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据 ContentReset effectTag重置文字节点</span></span><br><span class="line">    <span class="keyword">if</span> (effectTag &amp; ContentReset) &#123;</span><br><span class="line">      commitResetTextContent(nextEffect)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更新ref</span></span><br><span class="line">    <span class="keyword">if</span> (effectTag &amp; Ref) &#123;</span><br><span class="line">      <span class="keyword">const</span> current = nextEffect.alternate</span><br><span class="line">      <span class="keyword">if</span> (current !== <span class="literal">null</span>) &#123;</span><br><span class="line">        commitDetachRef(current)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据 effectTag 分别处理</span></span><br><span class="line">    <span class="keyword">const</span> primaryEffectTag =</span><br><span class="line">      effectTag &amp; (Placement | Update | Deletion | Hydrating)</span><br><span class="line">    <span class="keyword">switch</span> (primaryEffectTag) &#123;</span><br><span class="line">      <span class="comment">// 插入DOM</span></span><br><span class="line">      <span class="keyword">case</span> Placement: &#123;</span><br><span class="line">        commitPlacement(nextEffect)</span><br><span class="line">        <span class="comment">// ~ 取反</span></span><br><span class="line">        nextEffect.effectTag &amp;= ~Placement</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 插入DOM 并 更新DOM</span></span><br><span class="line">      <span class="keyword">case</span> PlacementAndUpdate: &#123;</span><br><span class="line">        <span class="comment">// 插入</span></span><br><span class="line">        commitPlacement(nextEffect)</span><br><span class="line"></span><br><span class="line">        nextEffect.effectTag &amp;= ~Placement</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 更新</span></span><br><span class="line">        <span class="comment">// current        是现在的 fiber</span></span><br><span class="line">        <span class="comment">// workInProgress 是新的 fiber</span></span><br><span class="line">        <span class="comment">// alternate      它们通过 alternate 连接</span></span><br><span class="line">        <span class="keyword">const</span> current = nextEffect.alternate</span><br><span class="line">        commitWork(current, nextEffect)</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// SSR</span></span><br><span class="line">      <span class="keyword">case</span> Hydrating: &#123;</span><br><span class="line">        nextEffect.effectTag &amp;= ~Hydrating</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// SSR</span></span><br><span class="line">      <span class="keyword">case</span> HydratingAndUpdate: &#123;</span><br><span class="line">        nextEffect.effectTag &amp;= ~Hydrating</span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> current = nextEffect.alternate</span><br><span class="line">        commitWork(current, nextEffect)</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 更新DOM</span></span><br><span class="line">      <span class="keyword">case</span> Update: &#123;</span><br><span class="line">        <span class="keyword">const</span> current = nextEffect.alternate</span><br><span class="line">        commitWork(current, nextEffect)</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 删除DOM</span></span><br><span class="line">      <span class="keyword">case</span> Deletion: &#123;</span><br><span class="line">        commitDeletion(root, nextEffect, renderPriorityLevel)</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    nextEffect = nextEffect.nextEffect</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>commitMutationEffects 会遍历 effectList，对每个 Fiber 节点执行如下三个操作：</p>
<ul>
<li>根据 ContentReset effectTag 重置文字节点</li>
<li>更新 ref</li>
<li>根据 effectTag 分别处理，其中 effectTag 包括(Placement | Update | Deletion | Hydrating)</li>
</ul>
<h5 id="Placement-effect"><a href="#Placement-effect" class="headerlink" title="Placement effect"></a>Placement effect</h5><p>当 Fiber 节点含有 Placement effectTag，意味着该 Fiber 节点对应的 DOM 节点需要插入到页面中。<a target="_blank" rel="noopener" href="https://github.com/facebook/react/blob/970fa122d8188bafa600e9b5214833487fbf1092/packages/react-reconciler/src/ReactFiberCommitWork.new.js#L1156">code</a></p>
<ol>
<li><p>获取父级 DOM 节点。其中 finishedWork 为传入的 Fiber 节点。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> parentFiber = getHostParentFiber(finishedWork)</span><br><span class="line"><span class="comment">// 父级DOM节点</span></span><br><span class="line"><span class="keyword">const</span> parentStateNode = parentFiber.stateNode</span><br></pre></td></tr></table></figure></li>
<li><p>获取 Fiber 节点的 DOM 兄弟节点</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> before = getHostSibling(finishedWork)</span><br></pre></td></tr></table></figure></li>
<li><p>根据 DOM 兄弟节点是否存在决定调用 parentNode.insertBefore 或 parentNode.appendChild 执行 DOM 插入操作。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// parentStateNode是否是rootFiber</span></span><br><span class="line"><span class="keyword">if</span> (isContainer) &#123;</span><br><span class="line">  insertOrAppendPlacementNodeIntoContainer(finishedWork, before, parent)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  insertOrAppendPlacementNode(finishedWork, before, parent)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>值得注意的是，getHostSibling（获取兄弟 DOM 节点）的执行很耗时，当在同一个父 Fiber 节点下依次执行多个插入操作，getHostSibling 算法的复杂度为指数级。</p>
<p>这是由于 Fiber 节点不只包括 HostComponent，所以 Fiber 树和渲染的 DOM 树节点并不是一一对应的。要从 Fiber 节点找到 DOM 节点很可能跨层级遍历。</p>
<p>考虑如下例子：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Item</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &lt;li&gt;&lt;li&gt;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">Item</span>/&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(<span class="xml"><span class="tag">&lt;<span class="name">App</span>/&gt;</span></span>, <span class="built_in">document</span>.getElementById(<span class="string">&#x27;root&#x27;</span>));</span><br></pre></td></tr></table></figure>

<p>对应的 Fiber 树和 DOM 树结构为：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Fiber树</span></span><br><span class="line">          child      child      child       child</span><br><span class="line">rootFiber -----&gt; App -----&gt; div -----&gt; Item -----&gt; li</span><br><span class="line"></span><br><span class="line"><span class="comment">// DOM树</span></span><br><span class="line">#root ---&gt; div ---&gt; li</span><br></pre></td></tr></table></figure>

<p>当在 div 的子节点 Item 前插入一个新节点 p，即 App 变为：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">Item</span> /&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对应的 Fiber 树和 DOM 树结构为：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Fiber树</span></span><br><span class="line">          child      child      child</span><br><span class="line">rootFiber -----&gt; App -----&gt; div -----&gt; p</span><br><span class="line">                                       | sibling       child</span><br><span class="line">                                       | -------&gt; Item -----&gt; li</span><br><span class="line"><span class="comment">// DOM树</span></span><br><span class="line">#root ---&gt; div ---&gt; p</span><br><span class="line">             |</span><br><span class="line">               ---&gt; li</span><br></pre></td></tr></table></figure>

<p>此时 DOM 节点 p 的兄弟节点为 li，而 Fiber 节点 p 对应的兄弟 DOM 节点为 <code>fiberP.sibling.child</code>, 即 fiber p 的兄弟 fiber Item 的子 fiber li。</p>
<h5 id="Update-effect"><a href="#Update-effect" class="headerlink" title="Update effect"></a>Update effect</h5><p>当 Fiber 节点含有 Update effectTag，意味着该 Fiber 节点需要更新。调用的方法为 commitWork，他会根据 Fiber.tag 分别处理。<a target="_blank" rel="noopener" href="https://github.com/facebook/react/blob/970fa122d8188bafa600e9b5214833487fbf1092/packages/react-reconciler/src/ReactFiberCommitWork.new.js#L1441">code</a></p>
<h6 id="FunctionComponent-mutation"><a href="#FunctionComponent-mutation" class="headerlink" title="FunctionComponent mutation"></a>FunctionComponent mutation</h6><p>当 fiber.tag 为 FunctionComponent，会调用 <a target="_blank" rel="noopener" href="https://github.com/facebook/react/blob/970fa122d8188bafa600e9b5214833487fbf1092/packages/react-reconciler/src/ReactFiberCommitWork.new.js#L314">commitHookEffectListUnmount</a>。该方法会遍历 effectList，执行所有 useLayoutEffect hook 的销毁函数。（mutation 阶段会执行 useLayoutEffect 的销毁函数!）</p>
<p>所谓“销毁函数”，见如下例子：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">useLayoutEffect(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// ...一些副作用逻辑</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// ...这就是销毁函数</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h6 id="HostComponent-mutation"><a href="#HostComponent-mutation" class="headerlink" title="HostComponent mutation"></a>HostComponent mutation</h6><p>当 fiber.tag 为 HostComponent，会调用 <a target="_blank" rel="noopener" href="https://github.com/facebook/react/blob/970fa122d8188bafa600e9b5214833487fbf1092/packages/react-dom/src/client/ReactDOMHostConfig.js#L423">commitUpdate</a>。</p>
<p>最终会在 <a target="_blank" rel="noopener" href="https://github.com/facebook/react/blob/970fa122d8188bafa600e9b5214833487fbf1092/packages/react-dom/src/client/ReactDOMComponent.js#L378">updateDOMProperties</a>中将 <a target="_blank" rel="noopener" href="https://github.com/facebook/react/blob/970fa122d8188bafa600e9b5214833487fbf1092/packages/react-reconciler/src/ReactFiberCompleteWork.new.js#L229">render 阶段 completeWork</a>中为 Fiber 节点赋值的 updateQueue 对应的内容渲染在页面上。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; updatePayload.length; i += <span class="number">2</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> propKey = updatePayload[i]</span><br><span class="line">  <span class="keyword">const</span> propValue = updatePayload[i + <span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 处理 style</span></span><br><span class="line">  <span class="keyword">if</span> (propKey === STYLE) &#123;</span><br><span class="line">    setValueForStyles(domElement, propValue)</span><br><span class="line">    <span class="comment">// 处理 DANGEROUSLY_SET_INNER_HTML</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (propKey === DANGEROUSLY_SET_INNER_HTML) &#123;</span><br><span class="line">    setInnerHTML(domElement, propValue)</span><br><span class="line">    <span class="comment">// 处理 children</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (propKey === CHILDREN) &#123;</span><br><span class="line">    setTextContent(domElement, propValue)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 处理剩余 props</span></span><br><span class="line">    setValueForProperty(domElement, propKey, propValue, isCustomComponentTag)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="Deletion-effect"><a href="#Deletion-effect" class="headerlink" title="Deletion effect"></a>Deletion effect</h5><p>fiber 节点含有 Deletion effectTag，意味着该 fiber 节点对应的 DOM 节点需要从页面中删除，调用的方法为 <a target="_blank" rel="noopener" href="https://github.com/facebook/react/blob/970fa122d8188bafa600e9b5214833487fbf1092/packages/react-reconciler/src/ReactFiberCommitWork.new.js#L1421">commitDeletion</a></p>
<p>该方法会执行以下操作：</p>
<ol>
<li>递归调用 Fiber 节点及其子孙 Fiber 节点中，fiber.tag 为 ClassComponent 的 <a target="_blank" rel="noopener" href="https://github.com/facebook/react/blob/970fa122d8188bafa600e9b5214833487fbf1092/packages/react-reconciler/src/ReactFiberCommitWork.new.js#L920">componentWillUnmount</a>生命周期钩子，从页面移除 Fiber 节点对应 DOM 节点</li>
<li>解绑 ref</li>
<li>调度 useEffect 的销毁函数</li>
</ol>
<h3 id="layout-阶段"><a href="#layout-阶段" class="headerlink" title="layout 阶段"></a>layout 阶段</h3><p>之所以称为 layout 阶段，是因为该阶段的代码都是在 DOM 渲染完成之后执行的。该阶段触发的生命周期钩子和 hook 能直接访问到改变后的 DOM，即该阶段是可以参与 DOM layout 的阶段。</p>
<p>类似前两个阶段，该阶段也是遍历 effectList，执行函数。</p>
<p>具体执行函数是 commitLayoutEffects。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">root.current = finishedWork</span><br><span class="line"></span><br><span class="line">nextEffect = firstEffect</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    commitLayoutEffects(root, lanes)</span><br><span class="line">  &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">    invariant(nextEffect !== <span class="literal">null</span>, <span class="string">&#x27;Should be working on an effect.&#x27;</span>)</span><br><span class="line">    captureCommitPhaseError(nextEffect, error)</span><br><span class="line">    nextEffect = nextEffect.nextEffect</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="keyword">while</span> (nextEffect !== <span class="literal">null</span>)</span><br><span class="line"></span><br><span class="line">nextEffect = <span class="literal">null</span></span><br></pre></td></tr></table></figure>

<h4 id="commitLayoutEffects"><a href="#commitLayoutEffects" class="headerlink" title="commitLayoutEffects"></a>commitLayoutEffects</h4><p><a target="_blank" rel="noopener" href="https://github.com/facebook/react/blob/970fa122d8188bafa600e9b5214833487fbf1092/packages/react-reconciler/src/ReactFiberWorkLoop.new.js#L2302">源码</a></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">commitLayoutEffects</span>(<span class="params">root: FiberRoot, committedLanes: Lanes</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (nextEffect !== <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> effectTag = nextEffect.effectTag</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用生命周期钩子和hook</span></span><br><span class="line">    <span class="keyword">if</span> (effectTag &amp; (Update | Callback)) &#123;</span><br><span class="line">      <span class="keyword">const</span> current = nextEffect.alternate</span><br><span class="line">      commitLayoutEffectOnFiber(root, current, nextEffect, committedLanes)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 赋值ref</span></span><br><span class="line">    <span class="keyword">if</span> (effectTag &amp; Ref) &#123;</span><br><span class="line">      commitAttachRef(nextEffect)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    nextEffect = nextEffect.nextEffect</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>commitLayoutEffects 做了两件事：</p>
<ol>
<li>commitLayoutEffectOnFiber（调用生命周期钩子和 hook 相关操作）</li>
<li>commitAttachRef（赋值 ref）</li>
</ol>
<h5 id="commitLayoutEffectOnFiber"><a href="#commitLayoutEffectOnFiber" class="headerlink" title="commitLayoutEffectOnFiber"></a>commitLayoutEffectOnFiber</h5><p><a target="_blank" rel="noopener" href="https://github.com/facebook/react/blob/970fa122d8188bafa600e9b5214833487fbf1092/packages/react-reconciler/src/ReactFiberCommitWork.new.js#L459">commitLayoutEffectOnFiber</a> 是别名，原名为 commitLifeCycles。</p>
<ul>
<li>对于 ClassComponent，他会通过 current === null?区分是 mount 还是 update，调用 componentDidMount (opens new window)或 componentDidUpdate。</li>
</ul>
<p>触发状态更新的 <code>this.setState</code> 如果赋值了第二个参数回调函数，也会在此时调用。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">this</span>.setState(&#123; <span class="attr">xxx</span>: <span class="number">1</span> &#125;, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;i am update~&#x27;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<ul>
<li>对于 FunctionComponent 及相关类型，他会调用 useLayoutEffect hook 的回调函数，调度 useEffect 的销毁与回调函数。<br>相关类型值特殊处理后的 FunctionComponent，比如 ForwardRef、React.memo 包裹的 FunctionComponent。</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> (finishedWork.tag) &#123;</span><br><span class="line">  <span class="comment">// 以下都是FunctionComponent及相关类型</span></span><br><span class="line">  <span class="keyword">case</span> FunctionComponent:</span><br><span class="line">  <span class="keyword">case</span> ForwardRef:</span><br><span class="line">  <span class="keyword">case</span> SimpleMemoComponent:</span><br><span class="line">  <span class="keyword">case</span> Block: &#123;</span><br><span class="line">    <span class="comment">// 执行useLayoutEffect的回调函数</span></span><br><span class="line">    commitHookEffectListMount(HookLayout | HookHasEffect, finishedWork)</span><br><span class="line">    <span class="comment">// 调度useEffect的销毁函数与回调函数</span></span><br><span class="line">    schedulePassiveEffects(finishedWork)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上一节介绍 update effect 时讲到，mutation 阶段会执行 useLayoutEffect hook 的销毁函数。</p>
<p>结合这里可以看到，useLayoutEffect hook 从上一次更新的销毁函数调用到本次更新的回调函数调用时同步执行的。</p>
<p>而 useEffect 则需要先调度，在 layout 阶段完成后再异步执行。</p>
<ul>
<li>对于 HostRoot，即 rootFiber，如果赋值了第三个参数回调函数，也会在此时调用。</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ReactDOM.render(<span class="xml"><span class="tag">&lt;<span class="name">App</span> /&gt;</span></span>, <span class="built_in">document</span>.querySelector(<span class="string">&#x27;#root&#x27;</span>), <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;i am mount~&#x27;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h5 id="commitAttachRef"><a href="#commitAttachRef" class="headerlink" title="commitAttachRef"></a>commitAttachRef</h5><p><a target="_blank" rel="noopener" href="https://github.com/facebook/react/blob/970fa122d8188bafa600e9b5214833487fbf1092/packages/react-reconciler/src/ReactFiberCommitWork.new.js#L823">code</a></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">commitAttachRef</span>(<span class="params">finishedWork: Fiber</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> ref = finishedWork.ref</span><br><span class="line">  <span class="keyword">if</span> (ref !== <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> instance = finishedWork.stateNode</span><br><span class="line">    <span class="comment">// 获取 DOM 实例</span></span><br><span class="line">    <span class="keyword">let</span> instanceToUse</span><br><span class="line">    <span class="keyword">switch</span> (finishedWork.tag) &#123;</span><br><span class="line">      <span class="keyword">case</span> HostComponent:</span><br><span class="line">        instanceToUse = getPublicInstance(instance)</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">      <span class="attr">default</span>:</span><br><span class="line">        instanceToUse = instance</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Moved outside to ensure DCE works with this flag</span></span><br><span class="line">    <span class="keyword">if</span> (enableScopeAPI &amp;&amp; finishedWork.tag === ScopeComponent) &#123;</span><br><span class="line">      instanceToUse = instance</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 更新 ref</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> ref === <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">      ref(instanceToUse)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      ref.current = instanceToUse</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="current-Fiber-树切换"><a href="#current-Fiber-树切换" class="headerlink" title="current Fiber 树切换"></a>current Fiber 树切换</h3><p>至此，整个 layout 阶段就结束了。<a target="_blank" rel="noopener" href="https://github.com/facebook/react/blob/970fa122d8188bafa600e9b5214833487fbf1092/packages/react-reconciler/src/ReactFiberWorkLoop.new.js#L2022">code</a></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root.current = finishedWork</span><br></pre></td></tr></table></figure>

<p>workInProgress Fiber 树在 commit 阶段完成渲染后会变为 current Fiber 树。这行代码的作用就是切换 fiberRootNode 指向的 current Fiber 树。</p>
<p>那么这行代码为什么在这里呢？（在 mutation 阶段结束后，layout 阶段开始前。）</p>
<p>我们知道 componentWillUnmount 会在 mutation 阶段执行。此时 current Fiber 树还指向前一次更新的 Fiber 树，在生命周期钩子内获取的 DOM 还是更新前的。</p>
<p>componentDidMount 和 componentDidUpdate 会在 layout 阶段执行。此时 current Fiber 树已经指向更新后的 Fiber 树，在生命周期钩子内获取的 DOM 就是更新后的。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://dedoyle.github.io/kuibu/2021/12/23/React-%E6%98%AF%E4%BB%80%E4%B9%88/" data-id="ckyfvgn6900010fib7slmh18r" data-title="React 状态更新" class="article-share-link">分享</a>
      
      
      
    </footer>
  </div>
  
</article>



  


</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/kuibu/archives/2022/01/">一月 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/kuibu/archives/2021/12/">十二月 2021</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/kuibu/2022/01/09/Event-Loop/">Event Loop</a>
          </li>
        
          <li>
            <a href="/kuibu/2021/12/23/React-%E6%98%AF%E4%BB%80%E4%B9%88/">React 状态更新</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2022 dong<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/kuibu/" class="mobile-nav-link">Home</a>
  
    <a href="/kuibu/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/kuibu/js/jquery-3.4.1.min.js"></script>



  
<script src="/kuibu/fancybox/jquery.fancybox.min.js"></script>




<script src="/kuibu/js/script.js"></script>





  </div>
</body>
</html>